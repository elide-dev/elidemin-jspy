@file:Suppress(
    "UNUSED",
    "NOTHING_TO_INLINE",
)

package elidemin.dev.elide

import com.github.ajalt.clikt.command.SuspendingCliktCommand
import com.github.ajalt.clikt.command.main
import com.github.ajalt.clikt.core.*
import com.github.ajalt.clikt.parameters.arguments.argument
import com.github.ajalt.clikt.parameters.arguments.multiple
import com.github.ajalt.clikt.parameters.arguments.optional
import com.github.ajalt.clikt.parameters.options.*
import com.github.ajalt.clikt.parameters.types.choice
import com.github.ajalt.clikt.parameters.types.path
import com.github.ajalt.clikt.parameters.types.uint
import kotlinx.atomicfu.atomic
import kotlinx.coroutines.*
import com.jakewharton.mosaic.runMosaic
import org.graalvm.nativeimage.ImageInfo
import org.graalvm.polyglot.*
import org.graalvm.polyglot.Context
import org.graalvm.polyglot.io.IOAccess
import java.lang.Runnable
import java.nio.file.Path
import java.nio.file.Paths
import java.util.concurrent.Executor
import java.util.concurrent.Executors
import java.util.concurrent.ThreadFactory
import javax.tools.ToolProvider
import kotlin.coroutines.CoroutineContext

private val languages = arrayOf(
    "js",
    "python",
)

//

private val engineCorePoolSize = 1u
private val engineThreadGroup = ThreadGroup("engine")

private object EngineThreadFactory : ThreadFactory {
    override fun newThread(r: Runnable): Thread = Thread(engineThreadGroup, r).apply {
        // nothing at this time
    }
}

private val engineThreadpool by lazy {
    Executors
        .newScheduledThreadPool(engineCorePoolSize.toInt(), EngineThreadFactory)
}

val Dispatchers.Engine: CoroutineDispatcher by lazy {
    engineThreadpool.asCoroutineDispatcher()
}

val Dispatchers.Virtual: CoroutineDispatcher by lazy {
    object : ExecutorCoroutineDispatcher(), Executor {
        override val executor: Executor get() = this

        override fun close() = error("Cannot be invoked on Dispatchers.LOOM")

        override fun dispatch(context: CoroutineContext, block: Runnable) {
            Thread.startVirtualThread(block)
        }

        override fun execute(command: Runnable) {
            Thread.startVirtualThread(command)
        }

        override fun toString() = "Dispatchers.LOOM"
    }
}

//

sealed class Command(protected val ctx: AppContext, name: String) : SuspendingCliktCommand(name)

class Python (ctx: AppContext): Command(ctx, "py") {
    init {
        context {
            allowInterspersedArgs = true
        }
    }

    // Command execution options
    private val command by option("-c", help = "Program passed in as string")
    private val module by option("-m", help = "Run library module as a script")

    // Interactive mode
    private val interactive by option("-i", help = "Interactive mode after executing script").flag()

    // Version & Help options
    // Note: Clikt automatically adds --help, but we add -h to match Python
    private val shortHelp by option("-h", help = "Print this help message and exit").flag()
    private val version by option("-V", "--version", help = "Print the Python version and exit").flag()

    // Verbosity options
    private val verbose by option("-v", help = "Verbose mode (trace imports)").counted()
    private val quiet by option("-q", help = "Don't print version and copyright messages in interactive mode").flag()

    // Debug options
    private val debug by option("-d", help = "Debug output").flag()

    // Optimization options
    private val optimize by option("-O", help = "Optimize generated bytecode").counted()
    // Note: -OO in Python is equivalent to -O -O or -O with count 2

    // Bytecode options
    private val dontWriteBytecode by option("-B", help = "Don't write .pyc files on import").flag()

    // Site packages options
    private val noUserSite by option("-s", help = "Don't add user site directory to sys.path").flag()
    private val noSite by option("-S", help = "Don't imply 'import site' on initialization").flag()

    // Environment options
    private val ignoreEnvironment by option("-E", help = "Ignore PYTHON* environment variables").flag()
    private val isolated by option("-I", help = "Isolated mode: implies -E and -s").flag()

    // Warning options
    private val warning by option("-W", help = "Warning control").multiple()

    // Source options
    private val skipFirstLine by option("-x", help = "Skip first line of source").flag()

    // Implementation-specific options
    private val implementationOption by option("-X", help = "Set implementation-specific option").multiple()

    // Bytecode validation
    private val hashBasedPycs by option("--check-hash-based-pycs", help = "Control how Python validates hash-based .pyc files")
        .choice("always", "default", "never")

    // Bytes warning
    private val bytesWarning by option("-b", help = "Issue warnings about bytes/str comparisons").counted()

    // Unbuffered output
    private val unbuffered by option("-u", help = "Force stdout and stderr to be unbuffered").flag()

    // UTF-8 mode
    private val utf8Mode by option("-U", help = "Force UTF-8 encoding for stdin/stdout/stderr").flag()

    // Import isolation
    private val isolatedImport by option("-P", help = "Run python with isolated import path").flag()

    // Scripts and arguments
    private val src by argument(help = "script to run").path()

    // Scripts and arguments
    private val args by argument(help = "arguments to pass").multiple().optional()

    override suspend fun run() {
        Statics.disableEngineAuxiliaryCache()
        val url = src.toUri()
        val source = Source.newBuilder("python", url.toURL()).build()
        ctx.useGuestContext(isolatedEngine = false) {
            eval(source).also {
                echo(it.toString())
            }
        }
    }
}

class JavaScript (ctx: AppContext): Command(ctx, "js") {
    private val src: Path by argument(help = "src file to run").path(
        mustExist = true,
        canBeFile = true,
        canBeDir = false,
        mustBeReadable = true,
    )

    override suspend fun run() {
        val url = src.toUri()
        val source = Source.newBuilder("js", url.toURL()).build()
        ctx.useGuestContext {
            eval(source).also {
                echo(it.toString())
            }
        }
    }
}

class JavaCompiler (ctx: AppContext) : Command(ctx, "javac") {
    init {
        context {
            allowInterspersedArgs = false
        }
    }

    override fun help(context: com.github.ajalt.clikt.core.Context): String =
        "Java compiler command-line interface"

    // Class paths and paths
    private val classpath by option("-classpath", "-cp", help = "Specify where to find user class files and annotation processors")
    private val sourcepath by option("-sourcepath", help = "Specify where to find input source files")
    private val bootClasspath by option("-bootclasspath", help = "Override location of bootstrap class files")
    private val extdirs by option("-extdirs", help = "Override location of installed extensions")
    private val endorseddirs by option("-endorseddirs", help = "Override location of endorsed standards path")
    private val outputDir by option("-d", help = "Specify where to place generated class files")

    // Module options (Java 9+)
    private val modulePath by option("--module-path", "-p", help = "Specify where to find application modules")
    private val moduleSourcePath by option("--module-source-path", help = "Specify where to find input source files for modules")
    private val addModules by option("--add-modules", help = "Root modules to resolve in addition to the initial modules")
    private val limitModules by option("--limit-modules", help = "Limit the universe of observable modules")
    private val addExports by option("--add-exports", help = "Specify packages to be considered as exported").multiple()
    private val addReads by option("--add-reads", help = "Specify module dependencies to be considered as readable").multiple()
    private val patchModule by option("--patch-module", help = "Override classes in module with classes from this path").multiple()

    // Source and target versions
    private val source by option("-source", help = "Provide source compatibility with specified release")
    private val target by option("-target", help = "Generate class files for specific VM version")
    private val release by option("--release", help = "Compile for a specific VM version. Supported releases: 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17")

    // Annotation processing options
    private val processor by option("-processor", help = "Names of the annotation processors to run; bypasses default discovery process")
    private val processorPath by option("-processorpath", help = "Specify where to find annotation processors")
    private val processorModulePath by option("--processor-module-path", help = "Specify a module path where to find annotation processors")
    private val parameters by option("-parameters", help = "Generate metadata for reflection on method parameters").flag()
    private val proc by option("-proc", help = "Control whether annotation processing and/or compilation is done")
        .choice("none", "only")
    private val printProcessorInfo by option("-printprocessorinfo", help = "Print information about which annotations a processor is asked to process").flag()
    private val aopt by option("-A", help = "Options to pass to annotation processors").multiple()

    // Output options
    private val generatedSourceOutputDir by option("-s", help = "Specify directory for generated source files")
    private val headerOutputDir by option("-h", help = "Specify directory for generated native header files")

    // Debug and diagnostic options
    private val g by option("-g", help = "Generate all debugging info").flag()
    private val nowarn by option("-nowarn", help = "Generate no warnings").flag()
    private val verbose by option("-verbose", help = "Output messages about what the compiler is doing").flag()
    private val deprecation by option("-deprecation", help = "Output source locations where deprecated APIs are used").flag()
    private val xlint by option("-Xlint", help = "Enable recommended warnings")
        .choice("all", "none", "cast", "classfile", "deprecation", "dep-ann", "divzero", "empty", "fallthrough",
            "finally", "options", "overrides", "path", "processing", "rawtypes", "serial", "static", "try", "unchecked", "varargs")
    private val werror by option("-Werror", help = "Terminate compilation if warnings occur").flag()

    // Encoding options
    private val encoding by option("-encoding", help = "Specify character encoding used by source files")

    // File management
    private val implicit by option("-implicit", help = "Specify whether to generate class files for implicitly referenced files")
        .choice("none", "class")
    private val pkginfo by option("-pkginfo", help = "Specify handling of package-info files")
        .choice("always", "legacy", "nonempty")

    // Miscellaneous options
    private val help by option("-help", "--help", "-?", help = "Print this help message").flag()
    private val version by option("-version", "--version", help = "Version information").flag()
    private val jOptionParam by option("-J", help = "Pass <flag> directly to the runtime system").multiple()
    private val profile by option("-profile", help = "Run in a specific profile (compact1, compact2, compact3)").choice("compact1", "compact2", "compact3")

    // Direct compiler options
    private val xdoclint by option("-Xdoclint", help = "Enable recommended checks for problems in javadoc comments").flag()
    private val xstdout by option("-Xstdout", help = "Redirect standard output")
    private val xdiags by option("-Xdiags", help = "Select diagnostic mode")
        .choice("compact", "verbose")

    // Source files to compile
    private val sourceFiles by argument().multiple()

    override suspend fun run() {
        // In a real implementation, this would invoke the Java compiler

        if (version) {
            echo("javac 17.0.0")
            return
        }

        // This is just a placeholder for the real compilation logic
        echo("Compiling Java source files: $sourceFiles")
        val compiler = ToolProvider.getSystemJavaCompiler()
        assert(compiler != null)
    }
}

class JarTool (ctx: AppContext) : Command(ctx, "jar") {
    init {
        context {
            allowInterspersedArgs = false
        }
    }

    override fun help(context: com.github.ajalt.clikt.core.Context): String =
        "Java Archive Tool command-line interface"

    // Main operation modes - jar requires one of these
    private val create by option("-c", "--create", help = "Create a new archive").flag()
    private val update by option("-u", "--update", help = "Update an existing archive").flag()
    private val extract by option("-x", "--extract", help = "Extract files from the archive").flag()
    private val list by option("-t", "--list", help = "List the table of contents for the archive").flag()
    private val index by option("-i", "--index", help = "Generate index information for the jar file").flag()
    private val describe by option("-d", "--describe-module", help = "Print the module descriptor, or automatic module name").flag()

    // Operation modifiers
    private val verbose by option("-v", "--verbose", help = "Generate verbose output").flag()
    private val file by option("-f", "--file", help = "Specify the archive file name")
    private val manifest by option("-m", "--manifest", help = "Include manifest information from the specified manifest file")
    private val noManifest by option("-M", "--no-manifest", help = "Don't create a manifest file for the entries").flag()
    private val mainClass by option("-e", "--main-class", help = "Set the entry point for standalone applications")
    private val storeOnly by option("-0", "--no-compress", help = "Store only; use no ZIP compression").flag()
    private val changeDir by option("-C", "--directory", help = "Change to the specified directory").pair()
    private val manifestVersion by option("--manifest-version", help = "Specify the manifest version")

    // Module options (Java 9+)
    private val moduleVersion by option("--module-version", help = "Specify the module version when creating or updating a modular jar")
    private val modulePath by option("-p", "--module-path", help = "Location of module dependence for generating hash")
    private val hashModules by option("--hash-modules", help = "Compute and record the hashes of modules matched by the given pattern")
    private val release by option("--release", help = "Create a multi-release jar file").pair()

    // Additional modifiers
    private val normalize by option("-n", "--normalize", help = "Normalize information in the new jar archive").flag()
    private val updatePaths by option("--update-paths", help = "Use the given file for filtering paths when updating").flag()
    private val pathfile by option("--pathfile", help = "Read the list of paths to process from the file")
    private val validatePaths by option("--validate-paths", help = "Validate the paths in the jar file").flag()
    private val doNotValidatePaths by option("--do-not-validate-paths", help = "Do not validate the paths in the jar file").flag()
    private val warn by option("--warn", help = "Enable jar warnings").flag()

    // Help and version
    private val helpOption by option("-h", "--help", help = "Print this help message").flag()
    private val versionOption by option("--version", help = "Print program version").flag()

    // Additional arguments
    private val arguments by argument().multiple().optional()

    override suspend fun run() {
        // In a real implementation, this would invoke the jar tool

        // Check for a valid operation mode
        if (!create && !update && !extract && !list && !index && !describe) {
            println("Error: One of the options {c,u,x,t,i,d} must be specified.")
            return
        }

        // This is just a placeholder for the real jar operation logic
        val mode = when {
            create -> "Creating"
            update -> "Updating"
            extract -> "Extracting"
            list -> "Listing"
            index -> "Indexing"
            describe -> "Describing"
            else -> "Unknown operation on"
        }

        println("$mode archive: ${file ?: "stdin/stdout"}")

        if (arguments?.isNotEmpty() == true) {
            println("Processing files/directories: $arguments")
        }
        val jartool = java.util.spi.ToolProvider.findFirst("jar")
        assert(jartool != null)
    }
}

class KotlinCompiler (ctx: AppContext): Command(ctx, "kotlinc") {
    override suspend fun run() {
        TODO("not yet supported")
    }
}

class Hello (ctx: AppContext) : Command(ctx, "hello") {
	private val debug by option(help = "enable debug").flag()
    private val info by option(help = "show bin info").flag()
    private val count by option(help = "number of times to print").uint().default(3u)
    private val jest by option(help = "jest").flag()

    override suspend fun run() {
        if (debug) {
            echo("debug mode active")
        }
        repeat(count.toInt()) {
            echo("Hello world!")
        }
        if (jest) runMosaic {
            renderJestSample()
        }
        if (info) {
            echo("Binary path: ${Statics.binaryPath}")
            echo("Binary home: ${Statics.binaryHome}")
            echo("Resources path: ${Statics.resourcesPath}")
        }
    }
}

class Entry : SuspendingCliktCommand("elide") {
    override suspend fun run() {
        // no-op
    }
}

///

// Flags to enable on the engine.
private val enableEngineFlags: List<String> = listOf()

// Whether to enable the auxiliary cache.
private val enableAuxCache = System.getProperty("elide.auxcache") != "false"
private val enableAuxCacheTracing = java.lang.Boolean.getBoolean("elide.auxcache.trace")

// Languages to pre-initialize.
private val preinitLangs = System.getProperty("elide.preinit", "js,python")

// Flags mapped to values on the engine.
private fun engineFlagValues(forceDisableAuxCache: Boolean = false): Map<String, String> {
    return mapOf(
        "engine.WarnOptionDeprecation" to "false",
        "engine.WarnVirtualThreadSupport" to "false",
    ).plus(
        if (
            !forceDisableAuxCache &&
            enableAuxCache &&
            ImageInfo.inImageCode() &&
            Statics.auxCacheEnabled()
        ) mapOf(
            "engine.PreinitializeContexts" to preinitLangs,
            "engine.Cache" to "/tmp/elide-auxcache.bin",
            "engine.TraceCache" to enableAuxCacheTracing.toString(),
        ) else emptyMap()
    )
}

object Statics {
    private var allArgs: Array<String>? = null
    private val initialized = atomic(false)
    private val ctx = atomic<AppContext?>(null)
    private val auxCache = atomic(true)

    const val pythonVersion = "3.11"
    const val graalPyVersion = "24.1"

    val binaryPath: Path by lazy {
        if (ImageInfo.inImageCode() && ImageInfo.isExecutable()) {
            Paths.get(ProcessHandle.current().info().command().orElse("labs"))
        } else {
            Paths.get(requireNotNull(System.getProperty("elide.binpath.override")))
        }
    }

    val binaryHome: Path by lazy {
        binaryPath.parent
    }

    val resourcesPath: Path by lazy {
        binaryPath.parent.resolve("resources")
    }

    fun requireInitialized() {
        check(initialized.value) { "Statics not initialized" }
    }

    fun initialize(args: Array<String>, activeCtx: AppContext) {
        if (initialized.compareAndSet(expect = false, update = true)) {
            allArgs = args
            ctx.value = activeCtx
        }
    }

    @Synchronized fun disableEngineAuxiliaryCache() {
        auxCache.value = false
    }

    @Synchronized fun auxCacheEnabled() = auxCache.value
}

// Flags to enable on the context.
private val enableContextFlags by lazy {
    listOf(
        // ---- JavaScript ----------------
        "js.allow-eval",
        "js.foreign-object-prototype",
        "js.intl-402",
        "js.strict",
        // Experimental:
        "js.iterator-helpers",
        "js.import-attributes",
        "js.performance",
        "js.lazy-translation",
        "js.json-modules",
        "js.shared-array-buffer",
        "js.error-cause",
        "js.new-set-methods",
        "js.foreign-hash-properties",
        "js.temporal",
        "js.atomics",
        "js.class-fields",
        "js.top-level-await",
        "js.async-context",
        "js.async-iterator-helpers",
        "js.async-stack-traces",
        "js.atomics-wait-async",
        "js.bind-member-functions",
        "js.esm-eval-returns-exports",
        "js.string-lazy-substrings",
        "js.zone-rules-based-time-zones",
        "js.direct-byte-buffer",
        // Enabled for use by polyfills or for experimental features:
        "js.java-package-globals",
        "js.graal-builtin",
        "js.polyglot-evalfile",
        "js.load",
        "js.polyglot-builtin",
        "js.global-property",
        "js.shadow-realm",
        "js.scope-optimization",
        "js.annex-b",
    )
}

// Flags mapped to values on the context.
private val contextFlagValues by lazy {
    mapOf(
        "js.timer-resolution" to "1",
        "js.commonjs-require-cwd" to ".",
        "js.debug-property-name" to "Debug",
        "js.ecmascript-version" to "2024",
        "js.unhandled-rejections" to "throw",
//        "python.HPyBackend" to "JNI",
//        "python.PosixModuleBackend" to "native",
//        "python.Sha3ModuleBackend" to "native",
//        "python.UseNativePrimitiveStorageStrategy" to "true",
//        "python.WarnExperimentalFeatures" to "false",
        "python.CoreHome" to "${Statics.resourcesPath}/python/python-home/lib/graalpy${Statics.graalPyVersion}",
        "python.SysPrefix" to "${Statics.resourcesPath}/python/python-home/lib/graalpy${Statics.graalPyVersion}",
        "python.CAPI" to "${Statics.resourcesPath}/python/python-home/lib/graalpy${Statics.graalPyVersion}",
        "python.PythonHome" to "${Statics.resourcesPath}/python/python-home",
        "python.StdLibHome" to "${Statics.resourcesPath}/python/python-home/lib/python${Statics.pythonVersion}",
    )
}

private inline fun doSafeOption(name: String, value: String, setter: (String, String) -> Unit) {
    try {
        setter(name, value)
    } catch (iae: IllegalArgumentException) {
        println("warn: option '${name}' is not valid or unavailable")
    }
}

private inline fun Engine.Builder.safeOption(name: String, value: String) =
    doSafeOption(name, value, this::option)

private inline fun Context.Builder.safeOption(name: String, value: String) =
    doSafeOption(name, value, this::option)

// Configure an engine instance.
private inline fun configureEngine(langs: Array<String>): Engine.Builder {
    Statics.requireInitialized()

    return (if (langs.isEmpty()) Engine.newBuilder() else Engine.newBuilder(*langs))
        .allowExperimentalOptions(true)
        .sandbox(SandboxPolicy.TRUSTED)
        .apply {
            enableEngineFlags.forEach { safeOption(it, "true") }
            engineFlagValues().forEach { safeOption(it.key, it.value) }
        }
}

// Singleton engine.
private inline fun createEngine(langs: Array<String>): Engine = configureEngine(langs).build()

fun createEmptyContextBuilder(
    lang: Array<String> = languages,
    engineGetter: (Array<String>) -> Engine = { _ -> globalEngine },
    engine: Engine? = null,
    attachEngine: Boolean = true,
): Context.Builder =
    Context.newBuilder(*lang)
        .allowIO(IOAccess.ALL)
        .allowEnvironmentAccess(EnvironmentAccess.INHERIT)
        .allowPolyglotAccess(PolyglotAccess.ALL)
        .allowValueSharing(true)
        .allowNativeAccess(true)
        .allowInnerContextOptions(true)
        .allowHostClassLoading(true)
        .allowExperimentalOptions(true)
        .apply {
            enableContextFlags.forEach { safeOption(it, "true") }
            contextFlagValues.filter {
                when {
                    it.key.startsWith("js.") -> lang.contains("js")
                    it.key.startsWith("python.") -> lang.contains("python")
                    else -> true
                }
            }.forEach {
                safeOption(it.key, it.value)
            }
        }
        .apply {
            if (attachEngine) {
                engine(engine ?: engineGetter.invoke(lang))
            }
        }

// Singleton engine.
val globalEngine by lazy {
    Statics.requireInitialized()
    createEngine(languages)
}

// Singleton context.
val globalContext by lazy {
    Statics.requireInitialized()
    createEmptyContextBuilder(attachEngine = false).build()
}

sealed interface AppContextAPI {
    val engine: (Array<String>) -> Engine
    val context: (Context.Builder) -> Context
}

typealias ContextBuilder = Context.Builder.() -> Unit

class AppContext (
    override val engine: (Array<String>) -> Engine = ::createEngine,
    override val context: (Context.Builder?) -> Context = { _: Context.Builder? -> globalContext },
) : AppContextAPI {
    suspend inline fun <R> useGuestContext(crossinline block: suspend Context.() -> R): R = withGuestContext {
        use { block() }
    }

    suspend inline fun <R> useGuestContext(
        isolatedEngine: Boolean,
        crossinline block: suspend Context.() -> R
    ): R = withGuestContext(isolatedEngine = isolatedEngine) {
        use { block() }
    }

    suspend inline fun <R> useGuestContext(
        crossinline builder: ContextBuilder,
        crossinline block: suspend Context.() -> R,
    ): R = withGuestContext(builder) {
        use { block() }
    }

    suspend inline fun <R> useGuestContext(
        isolatedEngine: Boolean,
        crossinline builder: ContextBuilder,
        crossinline block: suspend Context.() -> R,
    ): R = withGuestContext(builder, isolatedEngine) {
        use { block() }
    }

    suspend inline fun <R> withGuestContext(
        isolatedEngine: Boolean = true,
        crossinline block: suspend Context.() -> R
    ): R = withGuestContext({ /* no-op */ }, isolatedEngine, block)

    suspend inline fun <R> withGuestContext(
        crossinline builder: ContextBuilder,
        isolatedEngine: Boolean = true,
        crossinline block: suspend Context.() -> R,
    ): R = withContext(Dispatchers.Engine) {
        val engine = when (isolatedEngine) {
            true -> engine(emptyArray())
            false -> globalEngine
        }
        val ctxBuilder = createEmptyContextBuilder(
            attachEngine = true,
            engine = engine,
        )
        try {
            context.invoke(ctxBuilder.apply(builder)).use { ctx ->
                ctx.enter()

                try {
                    block.invoke(ctx)
                } finally {
                    ctx.leave()
                }
            }
        } finally {
            engine.close()
        }
    }
}

fun main(args: Array<String>) {
    System.setProperty(
        "polyglot.image-build-time.PreinitializeAllowExperimentalOptions",
        "true"
    )
    System.setProperty(
        "polyglot.engine.WarnVirtualThreadSupport",
        "false",
    )

    val ctx = AppContext()

    Statics.initialize(
        args,
        ctx,
    )
    val commands = mutableListOf<SuspendingCliktCommand>(
        Hello(ctx),
        JavaScript(ctx),
        Python(ctx),
        JavaCompiler(ctx),
        JarTool(ctx),
        KotlinCompiler(ctx),
    )

    runBlocking(Dispatchers.Default) {
        try {
            Entry()
                .subcommands(
                    *commands.toTypedArray()
                )
                .main(args)
        } catch (iae: IllegalArgumentException) {
            if (iae.message?.contains("is experimental and must be enabled with") == true) {
                iae.printStackTrace()
                println("warn: invalid option prevented image persist; message: ${iae.message}")
            } else {
                throw iae
            }
        }
    }
}
