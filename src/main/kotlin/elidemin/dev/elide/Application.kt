@file:Suppress(
    "UNUSED",
)

package elidemin.dev.elide

import com.github.ajalt.clikt.core.*
import com.github.ajalt.clikt.parameters.arguments.argument
import com.github.ajalt.clikt.parameters.arguments.multiple
import com.github.ajalt.clikt.parameters.arguments.optional
import com.github.ajalt.clikt.parameters.options.*
import com.github.ajalt.clikt.parameters.types.choice
import com.github.ajalt.clikt.parameters.types.path
import com.github.ajalt.clikt.parameters.types.uint
import org.graalvm.polyglot.Context
import org.graalvm.polyglot.Engine
import org.graalvm.polyglot.SandboxPolicy
import org.graalvm.polyglot.Source
import java.nio.file.Path
import java.util.function.Supplier
import javax.tools.ToolProvider


private val enablePkl = System.getProperty("elide.pkl") == "true"

private val languages = arrayOf(
    "js",
    "python",
)

sealed class Command(protected val ctx: AppContext, name: String) : CliktCommand(name)

class Python (ctx: AppContext): Command(ctx, "py") {
    init {
        context {
            allowInterspersedArgs = true
        }
    }

    // Command execution options
    private val command by option("-c", help = "Program passed in as string")
    private val module by option("-m", help = "Run library module as a script")

    // Interactive mode
    private val interactive by option("-i", help = "Interactive mode after executing script").flag()

    // Version & Help options
    // Note: Clikt automatically adds --help, but we add -h to match Python
    private val shortHelp by option("-h", help = "Print this help message and exit").flag()
    private val version by option("-V", "--version", help = "Print the Python version and exit").flag()

    // Verbosity options
    private val verbose by option("-v", help = "Verbose mode (trace imports)").counted()
    private val quiet by option("-q", help = "Don't print version and copyright messages in interactive mode").flag()

    // Debug options
    private val debug by option("-d", help = "Debug output").flag()

    // Optimization options
    private val optimize by option("-O", help = "Optimize generated bytecode").counted()
    // Note: -OO in Python is equivalent to -O -O or -O with count 2

    // Bytecode options
    private val dontWriteBytecode by option("-B", help = "Don't write .pyc files on import").flag()

    // Site packages options
    private val noUserSite by option("-s", help = "Don't add user site directory to sys.path").flag()
    private val noSite by option("-S", help = "Don't imply 'import site' on initialization").flag()

    // Environment options
    private val ignoreEnvironment by option("-E", help = "Ignore PYTHON* environment variables").flag()
    private val isolated by option("-I", help = "Isolated mode: implies -E and -s").flag()

    // Warning options
    private val warning by option("-W", help = "Warning control").multiple()

    // Source options
    private val skipFirstLine by option("-x", help = "Skip first line of source").flag()

    // Implementation-specific options
    private val implementationOption by option("-X", help = "Set implementation-specific option").multiple()

    // Bytecode validation
    private val hashBasedPycs by option("--check-hash-based-pycs", help = "Control how Python validates hash-based .pyc files")
        .choice("always", "default", "never")

    // Bytes warning
    private val bytesWarning by option("-b", help = "Issue warnings about bytes/str comparisons").counted()

    // Unbuffered output
    private val unbuffered by option("-u", help = "Force stdout and stderr to be unbuffered").flag()

    // UTF-8 mode
    private val utf8Mode by option("-U", help = "Force UTF-8 encoding for stdin/stdout/stderr").flag()

    // Import isolation
    private val isolatedImport by option("-P", help = "Run python with isolated import path").flag()

    // Scripts and arguments
    private val src by argument(help = "script to run").path()

    // Scripts and arguments
    private val args by argument(help = "arguments to pass").multiple().optional()

    override fun run() {
        val url = src.toUri()
        val source = Source.newBuilder("python", url.toURL()).build()
        val result = ctx.context.get().eval(source)
        echo(result.toString())
    }
}

class JavaScript (ctx: AppContext): Command(ctx, "js") {
    private val src: Path by argument(help = "src file to run").path(
        mustExist = true,
        canBeFile = true,
        canBeDir = false,
        mustBeReadable = true,
    )

    override fun run() {
        val url = src.toUri()
        val source = Source.newBuilder("js", url.toURL()).build()
        val result = ctx.context.get().eval(source)
        echo(result.toString())
    }
}

class JavaCompiler (ctx: AppContext) : Command(ctx, "javac") {
    init {
        context {
            allowInterspersedArgs = false
        }
    }

    override fun help(context: com.github.ajalt.clikt.core.Context): String =
        "Java compiler command-line interface"

    // Class paths and paths
    private val classpath by option("-classpath", "-cp", help = "Specify where to find user class files and annotation processors")
    private val sourcepath by option("-sourcepath", help = "Specify where to find input source files")
    private val bootClasspath by option("-bootclasspath", help = "Override location of bootstrap class files")
    private val extdirs by option("-extdirs", help = "Override location of installed extensions")
    private val endorseddirs by option("-endorseddirs", help = "Override location of endorsed standards path")
    private val outputDir by option("-d", help = "Specify where to place generated class files")

    // Module options (Java 9+)
    private val modulePath by option("--module-path", "-p", help = "Specify where to find application modules")
    private val moduleSourcePath by option("--module-source-path", help = "Specify where to find input source files for modules")
    private val addModules by option("--add-modules", help = "Root modules to resolve in addition to the initial modules")
    private val limitModules by option("--limit-modules", help = "Limit the universe of observable modules")
    private val addExports by option("--add-exports", help = "Specify packages to be considered as exported").multiple()
    private val addReads by option("--add-reads", help = "Specify module dependencies to be considered as readable").multiple()
    private val patchModule by option("--patch-module", help = "Override classes in module with classes from this path").multiple()

    // Source and target versions
    private val source by option("-source", help = "Provide source compatibility with specified release")
    private val target by option("-target", help = "Generate class files for specific VM version")
    private val release by option("--release", help = "Compile for a specific VM version. Supported releases: 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17")

    // Annotation processing options
    private val processor by option("-processor", help = "Names of the annotation processors to run; bypasses default discovery process")
    private val processorPath by option("-processorpath", help = "Specify where to find annotation processors")
    private val processorModulePath by option("--processor-module-path", help = "Specify a module path where to find annotation processors")
    private val parameters by option("-parameters", help = "Generate metadata for reflection on method parameters").flag()
    private val proc by option("-proc", help = "Control whether annotation processing and/or compilation is done")
        .choice("none", "only")
    private val printProcessorInfo by option("-printprocessorinfo", help = "Print information about which annotations a processor is asked to process").flag()
    private val aopt by option("-A", help = "Options to pass to annotation processors").multiple()

    // Output options
    private val generatedSourceOutputDir by option("-s", help = "Specify directory for generated source files")
    private val headerOutputDir by option("-h", help = "Specify directory for generated native header files")

    // Debug and diagnostic options
    private val g by option("-g", help = "Generate all debugging info").flag()
    private val nowarn by option("-nowarn", help = "Generate no warnings").flag()
    private val verbose by option("-verbose", help = "Output messages about what the compiler is doing").flag()
    private val deprecation by option("-deprecation", help = "Output source locations where deprecated APIs are used").flag()
    private val xlint by option("-Xlint", help = "Enable recommended warnings")
        .choice("all", "none", "cast", "classfile", "deprecation", "dep-ann", "divzero", "empty", "fallthrough",
            "finally", "options", "overrides", "path", "processing", "rawtypes", "serial", "static", "try", "unchecked", "varargs")
    private val werror by option("-Werror", help = "Terminate compilation if warnings occur").flag()

    // Encoding options
    private val encoding by option("-encoding", help = "Specify character encoding used by source files")

    // File management
    private val implicit by option("-implicit", help = "Specify whether to generate class files for implicitly referenced files")
        .choice("none", "class")
    private val pkginfo by option("-pkginfo", help = "Specify handling of package-info files")
        .choice("always", "legacy", "nonempty")

    // Miscellaneous options
    private val help by option("-help", "--help", "-?", help = "Print this help message").flag()
    private val version by option("-version", "--version", help = "Version information").flag()
    private val jOptionParam by option("-J", help = "Pass <flag> directly to the runtime system").multiple()
    private val profile by option("-profile", help = "Run in a specific profile (compact1, compact2, compact3)").choice("compact1", "compact2", "compact3")

    // Direct compiler options
    private val xdoclint by option("-Xdoclint", help = "Enable recommended checks for problems in javadoc comments").flag()
    private val xstdout by option("-Xstdout", help = "Redirect standard output")
    private val xdiags by option("-Xdiags", help = "Select diagnostic mode")
        .choice("compact", "verbose")

    // Source files to compile
    private val sourceFiles by argument().multiple()

    override fun run() {
        // In a real implementation, this would invoke the Java compiler

        if (version) {
            echo("javac 17.0.0")
            return
        }

        // This is just a placeholder for the real compilation logic
        echo("Compiling Java source files: $sourceFiles")
        val compiler = ToolProvider.getSystemJavaCompiler()
        assert(compiler != null)
    }
}

class JarTool (ctx: AppContext) : Command(ctx, "jar") {
    init {
        context {
            allowInterspersedArgs = false
        }
    }

    override fun help(context: com.github.ajalt.clikt.core.Context): String =
        "Java Archive Tool command-line interface"

    // Main operation modes - jar requires one of these
    private val create by option("-c", "--create", help = "Create a new archive").flag()
    private val update by option("-u", "--update", help = "Update an existing archive").flag()
    private val extract by option("-x", "--extract", help = "Extract files from the archive").flag()
    private val list by option("-t", "--list", help = "List the table of contents for the archive").flag()
    private val index by option("-i", "--index", help = "Generate index information for the jar file").flag()
    private val describe by option("-d", "--describe-module", help = "Print the module descriptor, or automatic module name").flag()

    // Operation modifiers
    private val verbose by option("-v", "--verbose", help = "Generate verbose output").flag()
    private val file by option("-f", "--file", help = "Specify the archive file name")
    private val manifest by option("-m", "--manifest", help = "Include manifest information from the specified manifest file")
    private val noManifest by option("-M", "--no-manifest", help = "Don't create a manifest file for the entries").flag()
    private val mainClass by option("-e", "--main-class", help = "Set the entry point for standalone applications")
    private val storeOnly by option("-0", "--no-compress", help = "Store only; use no ZIP compression").flag()
    private val changeDir by option("-C", "--directory", help = "Change to the specified directory").pair()
    private val manifestVersion by option("--manifest-version", help = "Specify the manifest version")

    // Module options (Java 9+)
    private val moduleVersion by option("--module-version", help = "Specify the module version when creating or updating a modular jar")
    private val modulePath by option("-p", "--module-path", help = "Location of module dependence for generating hash")
    private val hashModules by option("--hash-modules", help = "Compute and record the hashes of modules matched by the given pattern")
    private val release by option("--release", help = "Create a multi-release jar file").pair()

    // Additional modifiers
    private val normalize by option("-n", "--normalize", help = "Normalize information in the new jar archive").flag()
    private val updatePaths by option("--update-paths", help = "Use the given file for filtering paths when updating").flag()
    private val pathfile by option("--pathfile", help = "Read the list of paths to process from the file")
    private val validatePaths by option("--validate-paths", help = "Validate the paths in the jar file").flag()
    private val doNotValidatePaths by option("--do-not-validate-paths", help = "Do not validate the paths in the jar file").flag()
    private val warn by option("--warn", help = "Enable jar warnings").flag()

    // Help and version
    private val helpOption by option("-h", "--help", help = "Print this help message").flag()
    private val versionOption by option("--version", help = "Print program version").flag()

    // Additional arguments
    private val arguments by argument().multiple().optional()

    override fun run() {
        // In a real implementation, this would invoke the jar tool

        // Check for a valid operation mode
        if (!create && !update && !extract && !list && !index && !describe) {
            println("Error: One of the options {c,u,x,t,i,d} must be specified.")
            return
        }

        // This is just a placeholder for the real jar operation logic
        val mode = when {
            create -> "Creating"
            update -> "Updating"
            extract -> "Extracting"
            list -> "Listing"
            index -> "Indexing"
            describe -> "Describing"
            else -> "Unknown operation on"
        }

        println("$mode archive: ${file ?: "stdin/stdout"}")

        if (arguments?.isNotEmpty() == true) {
            println("Processing files/directories: $arguments")
        }
        val jartool = java.util.spi.ToolProvider.findFirst("jar")
        assert(jartool != null)
    }
}

class KotlinCompiler (ctx: AppContext): Command(ctx, "kotlinc") {
    override fun run() {
        TODO("not yet supported")
    }
}

class Pkl: NoOpCliktCommand("pkl")

class Hello (ctx: AppContext) : Command(ctx, "hello") {
	private val debug by option(help = "enable debug").flag()
    private val count by option(help = "number of times to print").uint().default(3u)

    override fun run() {
        if (debug) {
            echo("debug mode active")
        }
        repeat(count.toInt()) {
            echo("Hello world!")
        }
    }
}

class Entry : NoOpCliktCommand("elide")

///

// Flags to enable on the engine.
private val enableEngineFlags: List<String> = listOf(
    "engine.BackgroundCompilation",
    "engine.UsePreInitializedContext",
    "engine.Compilation",
    "engine.MultiTier",
    "engine.Splitting",
    "engine.OSR",
    "engine.CachePreinitializeContext",
    "compiler.Inlining",
    "compiler.EncodedGraphCache",
    "compiler.InlineAcrossTruffleBoundary",
)

// Flags mapped to values on the engine.
private val engineFlagValues: Map<String, String> = mapOf(
    "engine.Cache" to "./aux-img.bin",
)

private const val binhome = "/home/sam/workspace/labs/gvm-min/elidemin-purekt-truffle/build/native/nativeOptimizedCompile"
private const val binpath = "$binhome/labs"
private const val resources = "$binhome/resources"
private const val pythonVersion = "3.11"
private const val graalPyVersion = "24.1"

// Flags to enable on the context.
private val enableContextFlags = listOf(
    // ---- JavaScript ----------------
    "js.allow-eval",
    "js.atomics",
    "js.class-fields",
    "js.direct-byte-buffer",
    "js.global-property",
    "js.error-cause",
    "js.foreign-hash-properties",
    "js.foreign-object-prototype",
    "js.import-attributes",
    "js.intl-402",
    "js.iterator-helpers",
    "js.json-modules",
    "js.lazy-translation",
    "js.new-set-methods",
    "js.performance",
    "js.shared-array-buffer",
    "js.strict",
    "js.temporal",
    "js.top-level-await",
    // Experimental:
    "js.async-context",
    "js.async-iterator-helpers",
    "js.async-stack-traces",
    "js.annex-b",
    "js.atomics-wait-async",
    "js.bind-member-functions",
    "js.esm-eval-returns-exports",
    "js.scope-optimization",
    "js.string-lazy-substrings",
    "js.shadow-realm",
    "js.zone-rules-based-time-zones",
    // Enabled for use by polyfills or for experimental features:
    "js.java-package-globals",
    "js.graal-builtin",
    "js.polyglot-evalfile",
    "js.load",
    "js.polyglot-builtin",
    // ---- Python --------------------
    "python.NativeModules",
    "python.LazyStrings",
    "python.WithTRegex",
    "python.WithCachedSources",
    "python.UsePanama",
)

// Flags mapped to values on the context.
private val contextFlagValues = mapOf(
    "js.timer-resolution" to "1",
    "js.commonjs-require-cwd" to ".",
    "js.debug-property-name" to "Debug",
    "js.ecmascript-version" to "2024",
    "js.unhandled-rejections" to "throw",
    "python.HPyBackend" to "nfi",
    "python.PosixModuleBackend" to "native",
    "python.CoreHome" to "$resources/python/python-home/lib/graalpy$graalPyVersion",
    "python.SysPrefix" to "$resources/python/python-home/lib/graalpy$graalPyVersion",
    "python.CAPI" to "$resources/python/python-home/lib/graalpy$graalPyVersion",
    "python.PythonHome" to "$resources/python/python-home",
    "python.StdLibHome" to "$resources/python/python-home/lib/python$pythonVersion",
)

// Singleton engine.
private val globalEngine by lazy {
    Engine.newBuilder(*languages)
        .allowExperimentalOptions(true)
        .sandbox(SandboxPolicy.TRUSTED)
        .apply {
            enableEngineFlags.forEach { option(it, "true") }
            engineFlagValues.forEach { option(it.key, it.value) }
        }
        .build()
}

// Singleton context.
private val globalContext by lazy {
    Context.newBuilder(*languages)
        .engine(globalEngine)
        .allowAllAccess(true)
        .allowNativeAccess(true)
        .allowCreateThread(true)
        .allowCreateProcess(true)
        .allowInnerContextOptions(true)
        .allowHostClassLoading(true)
        .allowExperimentalOptions(true)
        .apply {
            enableContextFlags.forEach { option(it, "true") }
            contextFlagValues.forEach { option(it.key, it.value) }
        }
        .build()
}

sealed interface AppContext {
    val engine: Supplier<Engine>
    val context: Supplier<Context>
}

class AppContextImpl (
    override val engine: Supplier<Engine> = Supplier { globalEngine },
    override val context: Supplier<Context> = Supplier { globalContext },
) : AppContext

fun main(args: Array<String>) {
    val ctx = AppContextImpl()

    val commands = mutableListOf(
        Hello(ctx),
        JavaScript(ctx),
        Python(ctx),
        JavaCompiler(ctx),
        JarTool(ctx),
        KotlinCompiler(ctx),
        Pkl().subcommands(
            org.pkl.cli.commands.EvalCommand(),
        ),
    )

    Entry()
        .subcommands(
            *commands.toTypedArray()
        )
        .main(args)
}
